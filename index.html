<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Happy Hebrew Language Week 2026 ! ×©×‘×•×¢ ×”×©×¤×” ×”×¢×‘×¨×™×ª ×”'×ª×©×¤"×• ×©××—</title>
    <style>
        :root {
            --maxw: 900px;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            margin: 0;
            min-height: 100vh;
            background: #fff;
        }

        .stage {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            width: min(var(--maxw), calc(100vw - 48px));
            transition: top 220ms ease;
            padding: 24px 0;
            box-sizing: border-box;
        }

        body.centered .stage {
            top: calc(50vh - 64px);
        }

        body.topped .stage {
            top: 18px;
        }

        input[type="text"] {
            width: 100%;
            font-size: 16px;
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            box-sizing: border-box;
            text-align: center;
        }

        .fileUpload {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            gap: 8px;
            align-items: center;
        }

        .fileUpload label {
            cursor: pointer;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border-radius: 6px;
            font-size: 14px;
            transition: background 0.2s;
        }

        .fileUpload label:hover {
            background: #0056b3;
        }

        .fileUpload input[type="file"] {
            display: none;
        }

        .fileUpload .status {
            font-size: 13px;
            color: #666;
        }

        #output {
            margin-top: 16px;
            display: flex;
            justify-content: center;
        }

        #scrollBox {
            width: 100%;
            border: 1px solid #e5e5e5;
            border-radius: 10px;
            background: #fafafa;
            overflow-y: auto;
            box-sizing: border-box;
            padding: 10px 12px;
            text-align: start;
        }

        ul, ol {
            margin: 0;
            padding-left: 22px;
        }

        .keyLine strong {
            font-weight: 700;
        }
    </style>
</head>
<body class="centered">
<div class="stage">
        <input
            id="keyInput"
            type="text"
            placeholder="Loading ... ×˜×•×¢×Ÿ"
            autocomplete="off"
            disabled
            dir="ltr"
    />
    <div class="fileUpload">
        <label for="fileInput">Load Custom Word List</label>
        <input type="file" id="fileInput" accept=".txt" />
        <span class="status" id="fileStatus"></span>
    </div>
    <div id="output">
        <div id="scrollBox" style="display:none;"></div>
    </div>
</div>

<script>
    const FILE_1 = "eng_sigs.json.gz";
    const FILE_2 = "heb_sigs.json.gz";

    let mapping = {};
    let maxListLen = 0;

    const inputEl = document.getElementById("keyInput");
    const scrollBox = document.getElementById("scrollBox");
    const fileInput = document.getElementById("fileInput");
    const fileStatus = document.getElementById("fileStatus");

    function sortKey(s) {
        return [...s.trim().normalize("NFC")]
            .sort((a, b) => a.localeCompare(b))
            .join("");
    }

    function startsWithHebrew(s) {
        const t = s.trim();
        if (!t) return false;
        const ch = [...t][0];
        return /\p{Script=Hebrew}/u.test(ch);
    }

    /* ğŸ”§ FIX HERE */
    function setInputDirFromValue() {
        const t = inputEl.value.trim();
        if (!t) {
            inputEl.dir = "ltr"; // reset so placeholder always looks correct
            return;
        }
        inputEl.dir = startsWithHebrew(t) ? "rtl" : "ltr";
    }

    function setLayoutMode() {
        const hasText = !!inputEl.value.trim();
        const hasFocus = document.activeElement === inputEl;
        document.body.className = (!hasText && !hasFocus) ? "centered" : "topped";
    }

    function setScrollBoxMaxHeight() {
        const probeLi = document.createElement("li");
        probeLi.textContent = "X";
        const probeOl = document.createElement("ol");
        probeOl.appendChild(probeLi);
        probeOl.style.margin = "0";
        probeOl.style.paddingLeft = "22px";

        scrollBox.replaceChildren(probeOl);
        scrollBox.style.display = "";

        const lineH = Math.max(18, Math.round(probeLi.getBoundingClientRect().height || 20));
        scrollBox.replaceChildren();

        const items = 1 + maxListLen;
        const padding = 10 + 10 + 4;
        const desired = items * lineH + padding;
        const cap = Math.max(160, Math.floor(window.innerHeight * 0.60));

        scrollBox.style.maxHeight = Math.min(desired, cap) + "px";
    }

    function escapeHtml(s) {
        return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
    }

    function renderList(sortedKey, words, rtl) {
        scrollBox.replaceChildren();

        if (!sortedKey) {
            scrollBox.style.display = "none";
            return;
        }

        const arr = Array.isArray(words) ? words.slice() : [];
        const count = arr.length;
        arr.sort((a, b) => String(a).localeCompare(String(b)));

        const wrapper = document.createElement("div");
        wrapper.dir = rtl ? "rtl" : "ltr";

        const ulKey = document.createElement("ul");
        ulKey.className = "keyLine";
        const liKey = document.createElement("li");
        liKey.innerHTML = `<strong>${escapeHtml(sortedKey)}</strong> (${count})`;
        ulKey.appendChild(liKey);

        const ol = document.createElement("ol");
        for (const w of arr) {
            const li = document.createElement("li");
            li.textContent = w;
            ol.appendChild(li);
        }

        wrapper.appendChild(ulKey);
        wrapper.appendChild(ol);

        scrollBox.appendChild(wrapper);
        scrollBox.style.display = "";
    }

    function updateLookup() {
        setInputDirFromValue();
        setLayoutMode();

        const trimmed = inputEl.value.trim();
        if (!trimmed) return renderList("", [], false);

        const key = sortKey(trimmed);
        const words = Object.prototype.hasOwnProperty.call(mapping, key) ? mapping[key] : [];
        renderList(key, words, startsWithHebrew(trimmed));
    }

    inputEl.addEventListener("input", updateLookup);
    inputEl.addEventListener("focus", updateLookup);
    inputEl.addEventListener("blur", updateLookup);

    async function gunzipToText(uint8) {
        const ds = new DecompressionStream("gzip");
        const decompressed = new Blob([uint8]).stream().pipeThrough(ds);
        return await new Response(decompressed).text();
    }

    async function fetchAndLoadGzJson(url) {
        const resp = await fetch(url, {cache: "no-store"});
        const buf = await resp.arrayBuffer();
        return JSON.parse(await gunzipToText(new Uint8Array(buf)));
    }

    function normalizeAndSortMapping(obj) {
        const out = {};
        for (const [k, v] of Object.entries(obj)) {
            out[sortKey(k).replace(/[\u200E\u200F]/g, "").trim()] = v;
        }
        return out;
    }

    function mergeMappings(target, src) {
        for (const [k, v] of Object.entries(src)) {
            const arr = Array.isArray(v) ? v : [];
            if (!Object.prototype.hasOwnProperty.call(target, k)) {
                target[k] = arr.slice();
            } else {
                const seen = new Set(target[k]);
                for (const w of arr) {
                    if (!seen.has(w)) {
                        target[k].push(w);
                        seen.add(w);
                    }
                }
            }
        }
    }

    function computeMaxListLen(mapObj) {
        let m = 0;
        for (const v of Object.values(mapObj)) {
            if (Array.isArray(v)) m = Math.max(m, v.length);
        }
        return m;
    }

    function buildMappingFromWords(words) {
        const newMapping = {};
        for (const word of words) {
            const trimmed = word.trim();
            if (!trimmed) continue;
            
            const key = sortKey(trimmed);
            if (!Object.prototype.hasOwnProperty.call(newMapping, key)) {
                newMapping[key] = [];
            }
            // Avoid duplicates within this file
            if (!newMapping[key].includes(trimmed)) {
                newMapping[key].push(trimmed);
            }
        }
        return newMapping;
    }

    async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        fileStatus.textContent = "Loading...";
        fileStatus.style.color = "#666";

        try {
            const text = await file.text();
            const words = text.split(/\r?\n/);
            const newMapping = buildMappingFromWords(words);
            
            mergeMappings(mapping, newMapping);
            maxListLen = computeMaxListLen(mapping);
            setScrollBoxMaxHeight();
            
            const wordCount = words.filter(w => w.trim()).length;
            const sigCount = Object.keys(newMapping).length;
            fileStatus.textContent = `Loaded ${wordCount} words (${sigCount} signatures)`;
            fileStatus.style.color = "#28a745";
            
            updateLookup();
        } catch (error) {
            fileStatus.textContent = "Error loading file";
            fileStatus.style.color = "#dc3545";
            console.error("File upload error:", error);
        }

        // Reset input so the same file can be reloaded
        event.target.value = "";
    }

    fileInput.addEventListener("change", handleFileUpload);

    (async () => {
        const merged = {};
        mergeMappings(merged, normalizeAndSortMapping(await fetchAndLoadGzJson(FILE_1)));
        mergeMappings(merged, normalizeAndSortMapping(await fetchAndLoadGzJson(FILE_2)));
        mapping = merged;

        maxListLen = computeMaxListLen(mapping);

        inputEl.disabled = false;
        inputEl.placeholder = "Enter a word ×›×ª×‘×• ××©×”×• ×›××Ÿ";

        setScrollBoxMaxHeight();
        updateLookup();
    })();
</script>
</body>
</html>
